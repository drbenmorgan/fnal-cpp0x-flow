#ifndef CPP0X_TYPE_TRAITS
#define CPP0X_TYPE_TRAITS

// ======================================================================
//
// type_traits - accommodations for as-yet unsupported C++0X features
//
// ----------------------------------------------------------------------
//
// This source file is intended for only short-term use.  Once compilers
// support the necessary C++0X features, this file should be no longer
// used and should go away.
//
// ======================================================================

#include "cpp0x/detail/config"

// ----------------------------------------------------------------------
// <type_traits>

#if defined(CPP0X_HAS_TYPE_TRAITS_HDR)
  #include <type_traits>

#else
  #include "boost/mpl/if.hpp"
  #include "boost/type_traits.hpp"
  #include "boost/utility/enable_if.hpp"
  #include "boost/utility/result_of.hpp"
  #if BOOST_VERSION < 104500
    #include "cpp0x/detail/add_rv_ref"
  #endif
  namespace std {
    // helper class
    using ::boost::integral_constant;
    using ::boost::true_type;
    using ::boost::false_type;

    // primary type categories
    using ::boost::is_void;
    using ::boost::is_integral;
    using ::boost::is_floating_point;
    using ::boost::is_array;
    using ::boost::is_pointer;
    #if BOOST_VERSION >= 104400
      using ::boost::is_lvalue_reference;
      using ::boost::is_rvalue_reference;
    #else
      template< class T >
        struct is_lvalue_reference : public ::boost::is_reference<T> { };
      template<class> struct is_rvalue_reference : public false_type { };
      #if defined(CPP0X_HAS_RVALUE_REFERENCES)
        template<class T>
          struct is_rvalue_reference<T&&> : public true_type { };
      #endif
    #endif
    using ::boost::is_member_object_pointer;
    using ::boost::is_member_function_pointer;
    using ::boost::is_enum;
    using ::boost::is_union;
    using ::boost::is_class;
    using ::boost::is_function;

    // composite type categories
    using ::boost::is_reference;
    using ::boost::is_arithmetic;
    using ::boost::is_fundamental;
    using ::boost::is_object;
    using ::boost::is_scalar;
    using ::boost::is_compound;
    using ::boost::is_member_pointer;

    // type properties
    using ::boost::is_const;
    using ::boost::is_volatile;
    template<class> struct is_trivial : public false_type { };
    template<class> struct is_trivially_copyable : public false_type { };
    template<class> struct is_standard_layout : public false_type { };
    using ::boost::is_pod;
    template<class> struct is_literal_type : public false_type { };
    using ::boost::is_empty;
    using ::boost::is_polymorphic;
    using ::boost::is_abstract;
    //is_constructible
    //is_nothrow_constructible
    template<class> struct has_default_constructor : public false_type { };
    template<class> struct has_copy_constructor : public false_type { };
    template<class> struct has_copy_assign : public false_type { };
    template<class> struct has_move_constructor : public false_type { };
    template<class> struct has_move_assign : public false_type { };
    template<class> struct has_trivial_default_constructor : public false_type { };
    using ::boost::has_trivial_copy_constructor;
    template<class> struct has_trivial_move_constructor : public false_type { };
    template<class> struct has_trivial_copy_assign : public false_type { };
    template<class> struct has_trivial_move_assign : public false_type { };
    using ::boost::has_trivial_destructor;
    using ::boost::has_nothrow_default_constructor;
    using ::boost::has_nothrow_copy_constructor;
    template<class> struct has_nothrow_move_constructor : public false_type { };
    template<class> struct has_nothrow_copy_assign : public false_type { };
    template<class> struct has_nothrow_move_assign : public false_type { };
    using ::boost::has_virtual_destructor;
    using ::boost::is_signed;
    using ::boost::is_unsigned;
    using ::boost::alignment_of;
    using ::boost::rank;
    using ::boost::extent;

    // type relations
    using ::boost::is_same;
    using ::boost::is_base_of;
    using ::boost::is_convertible;

    // const-volatile modifications
    using ::boost::remove_const;
    using ::boost::remove_volatile;
    using ::boost::remove_cv;
    using ::boost::add_const;
    using ::boost::add_volatile;
    using ::boost::add_cv;

    // reference modifications
    using ::boost::remove_reference;
    template< class T >
      struct add_lvalue_reference : public ::boost::add_reference<T> { };
    using ::boost::add_rvalue_reference;

    // sign modifications
    using ::boost::make_signed;
    using ::boost::make_unsigned;

    // array modifications
    using ::boost::remove_extent;
    using ::boost::remove_all_extents;

    // pointer modifications
    using ::boost::remove_pointer;
    using ::boost::add_pointer;

    // other transformations
    using ::boost::aligned_storage;
    //aligned_union
    using ::boost::decay;
    template< bool b, class T = void >
      struct enable_if : public ::boost::enable_if_c<b,T> { };
    template< bool b, class T, class F >
      struct conditional : public ::boost::mpl::if_c<b,T,F> { };
    using ::boost::common_type;
    //underlying_type
    template< class T >
      struct result_of : public ::boost::result_of<T> { };
  }

#endif

// ======================================================================

#endif

// vi: set filetype=cpp:expandtab:shiftwidth=2:
